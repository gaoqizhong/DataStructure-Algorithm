# 96.不同的二叉搜索树

### 题目

【middle】给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

### 方法

【数学归纳法】

这是一道经典的数学归纳问题，几乎找不出其他方法。数学归纳法的难点在于：如何巧妙的定义状态转移方程，以使得数学归纳能够实现

首先，我们知道二叉搜索树与有序序列的关系：

- 二叉搜索树中序遍历的结果是有序序列
- 中序遍历结果是有序序列的二叉树，一定是二叉搜索树

然后，我们还知道一个二级结论：

- 取出有序序列的中间值作为根节点，将其两边作为左右子树，可以递归地构建一棵二叉搜索树

可以明显感觉出来，这个二级结论对本题很有用，这是我们建立状态转移方程的突破口

在本题中，我们这样定义状态转移方程：

- G(n)：n个节点能构成的二叉搜索树的种数
- F(i, n)：以i为根节点，n个节点能构成的二叉搜索树的种数。这是G(n)的辅助方程

G与F之间的关系是一目了然的：

**20220529-04**

但是这样还不足以进行数学归纳，因为数学归纳要求只能有G，所以我们必须想办法再建立一个G与F的关系，从而把F消掉

结合我们刚才讲的二级结论，我们发现，F所定义的每一棵搜索二叉树，都是：

- 以i为根节点
- 左子树为：由i - 1个节点构成的二叉搜索树，有G(i - 1)种
- 右子树为：由n - i个节点构成的二叉搜索树，有G(n - i)种

那么，我们马上就可以得出这个关系：

**20220529-05**

我们将这两个关系联立，消去F，就可以得到最终的状态转移方程：

**20220529-06**

至此，此题得解。它的推理过程不难，但不容易想到；它的代码十分简洁美观。

【时间复杂度】O(n?)

【空间复杂度】O(n)

### 代码

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> G(n + 1, 0);
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i <= n; i++)		// 此层迭代计算G(n)
            for (int j = 1; j <= i; j++)	// 此层迭代执行状态转移方程
                G[i] += G[j - 1] * G[i - j];

        return G[n];
    }
};
```
